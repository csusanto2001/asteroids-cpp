// Class automatically generated by Dev-C++ New Class wizard

#include "asteroid.h" // class's header file

#include "engine.h"

#include <cmath>
#include <graphics.h>
#include <stdlib.h>

// class constructor
Asteroid::Asteroid()
{                   
	position = Point2D(rand() % WINDOW_WIDTH, rand() % WINDOW_HEIGHT);
	double rotationAngle = fmod(rand(), M_2_PI);
	speed = Point2D(sin(rotationAngle), -cos(rotationAngle)) * ASTEROID_SPEED;
	
    size = 4; // Initial size
    
    rotation = 0;
    rotationSpeed = std::fmod(rand(), ASTEROID_MAX_ROTATION) - ASTEROID_MAX_ROTATION / 2;
    
    // Random asteroid shape
    double variation = ASTEROID_SIZE_VARIATION * size / 4;
    for (int i = 0; i < ASTEROID_CORNERS; i++)
    {
        sizeVariation[i] = fmod(rand(), variation) - (variation / 2);
    }
}

Asteroid::Asteroid(Point2D newPosition, int newSize, Point2D newSpeed)
{
                           
    position = newPosition;
    speed = newSpeed;
    size = newSize;
    
    rotation = 0;
    rotationSpeed = std::fmod(rand(), ASTEROID_MAX_ROTATION) - ASTEROID_MAX_ROTATION / 2;
    
    double variation = ASTEROID_SIZE_VARIATION * size / 4;
    for (int i = 0; i < ASTEROID_CORNERS; i++)
    {
        sizeVariation[i] = fmod(rand(), variation) - (variation / 2);
    }
}

// class destructor
Asteroid::~Asteroid()
{
	// insert your code here
}

void Asteroid::advance(double delta)
{
     if (size > 0)
     {
         position += speed * delta;
         if (position.x < -10) position.x = WINDOW_WIDTH + 10;
         if (position.x > WINDOW_WIDTH + 10) position.x = -10;
         if (position.y < -10) position.y = WINDOW_HEIGHT + 10;
         if (position.y > WINDOW_HEIGHT + 10) position.y = -10;
         
         rotation += rotationSpeed * delta;
     }
     else
     {
         explosionTime += delta;
     }
}

void Asteroid::explode()
{
     size = 0;
     explosionTime = 0;
}

void Asteroid::draw()
{
     if (size > 0)
     {
         double angleStep = M_2_PI;
         double dist = size * ASTEROID_SIZE_MULTIPLIER + sizeVariation[0];
         int lastX = (int)(position.x + dist * sin(rotation));
         int lastY = (int)(position.y - dist * cos(rotation));
         
         int firstX = lastX;
         int firstY = lastY;
         
         for (int i = 1; i < ASTEROID_CORNERS - 1; i++)
         {
             dist = size * ASTEROID_SIZE_MULTIPLIER + sizeVariation[i];
             int currentX = (int)(position.x + dist * sin(rotation + i * angleStep));
             int currentY = (int)(position.y - dist * cos(rotation + i * angleStep));
             line(lastX, lastY, currentX, currentY);
             lastX = currentX;
             lastY = currentY;
         }
         
         line(lastX, lastY, firstX, firstY);
     }
     else
     {
         double angleStep = M_2_PI / ASTEROID_CORNERS;
         for (int i = 0; i < ASTEROID_CORNERS; i++)
         {
             double distance = explosionTime * (100 + 20 * sizeVariation[i]);
             circle((int)(position.x + distance * sin(i * angleStep)), 
                 (int)(position.y - distance * cos(i * angleStep)),
                 4);
         }
     }
}

Point2D Asteroid::getPosition()
{
    return position;
}

Point2D Asteroid::getSpeed()
{
    return speed;
}

int Asteroid::getSize()
{
    return size;
}

double Asteroid::getExplosionTime()
{
    return explosionTime;
}
